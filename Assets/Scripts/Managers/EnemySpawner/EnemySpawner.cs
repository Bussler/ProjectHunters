using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// This class is responsible for spawning enemies in waves. Set up as singleton pattern
public class EnemySpawner : MonoBehaviour
{
    public static EnemySpawner Instance;

    public List<Wave> waves; // List of waves to spawn

    [Header("Spawner Attributes")]
    [SerializeField]
    private int nAutogeneratedWaves = 10; // Create n waves automatically

    [SerializeField]
    private List<GameObject> enemiesForAutogeneration; // Randomly select enemies from this list for auto waves

    [SerializeField]
    private float waveInterval; // Time between waves

    [SerializeField]
    private int maxEnemiesAllowed; // Maximum number of enemies allowed to be alive at once

    [SerializeField]
    private Vector2 spawnPositionInterval; // Position where enemies should spawn ([-x, x], [-y, y])

    private int currentWave; // Index of current wave
    private float spawnTimer; // Timer to check spawn of next enemy in current wave
    private int enemiesAlive; // Number of enemies currently alive
    private int enemiesKilled; // Number of enemies killed
    private int neededEnemieQuota; // Number of killed enemies needed to win
    private bool waitingForNextWave = false; // Flag to check if waiting for next wave


    void Awake()
    {
        if (Instance != null)
        {
            Destroy(this.gameObject);
            return;
        }

        Instance = this;
    }
    void Start()
    {
        if (nAutogeneratedWaves != 0)
        {
            this.waves = GenerateWaves(this.nAutogeneratedWaves);
        }

        foreach (Wave wave in waves)
        {
            if (wave.waveQuota == 0)
                wave.CalculateWaveQuota();
            neededEnemieQuota += wave.waveQuota;
        }
    }

    void FixedUpdate()
    {
        if(currentWave >= waves.Count)
            return;

        //Check if current wave is finished: if all enemies have been spawned, move to next wave
        if (currentWave < waves.Count - 1 && waves[currentWave].spawnCount >= waves[currentWave].waveQuota && !waitingForNextWave)
        {
            waitingForNextWave = true;
            StartCoroutine(BeginNextWave());
        }

        //Spawn enemies from current wave
        spawnTimer += Time.deltaTime;
        if (spawnTimer >= waves[currentWave].spawnInterval)
        {
            spawnTimer = 0;
            SpawnWave();
        }

    }

    // Coroutine to start next wave after waveInterval
    IEnumerator BeginNextWave()
    {
        yield return new WaitForSeconds(waveInterval);

        if (currentWave < waves.Count - 1)
        {
            currentWave++;
            spawnTimer = 0;
        }
        waitingForNextWave = false;
    }

    // Spawn enemies from current wave: Go through each enemy group and spawn enemies
    private void SpawnWave()
    {
        Wave wave = waves[currentWave];
        if (wave.spawnCount < wave.waveQuota)
        {
            foreach (EnemyGroup enemyGroup in wave.enemyGroups)
            {
                for (int i = 0; i < enemyGroup.spawnIntensity; i++)
                {
                    if (enemyGroup.spawnCount < enemyGroup.enemyCount)
                    {
                        if (enemiesAlive >= maxEnemiesAllowed)
                            return;

                        // Spawn enemy
                        Vector2 spawnPosition = new Vector2(Random.Range(-spawnPositionInterval.x, spawnPositionInterval.x), Random.Range(-spawnPositionInterval.y, spawnPositionInterval.y));
                        GameObject gameObject = ObjectPoolManager.Instance.SpawnObject(enemyGroup.enemyPrefab, spawnPosition, Quaternion.identity, ObjectPoolManager.PoolType.Enemy);

                        StatManager enemyStats = gameObject.GetComponent<StatManager>();
                        if (enemyStats != null)
                            enemyStats.Initilize();

                        enemyGroup.spawnCount++;
                        wave.spawnCount++;
                        enemiesAlive++;
                    }
                }
            }
        }
    }

    private GameObject GetRandomEnemyPrefab()
    {
        if (enemiesForAutogeneration.Count == 0)
            return null;
        return enemiesForAutogeneration[Random.Range(0, enemiesForAutogeneration.Count)];
    }

    private List<Wave> GenerateWaves(int nWaves)
    {
        List<Wave> waves = new List<Wave>();
        for (int i = 1; i < nWaves+1; i++)
        {
            Wave wave = ScriptableObject.CreateInstance<Wave>();
            wave.name = "Wave " + i;
            wave.spawnInterval = 1;
            wave.enemyGroups = new List<EnemyGroup>();

            EnemyGroup enemyGroup = new EnemyGroup();
            enemyGroup.enemyCount = 10 * i;
            enemyGroup.spawnIntensity = 5;
            enemyGroup.enemyPrefab = GetRandomEnemyPrefab();
            wave.enemyGroups.Add(enemyGroup);

            waves.Add(wave);
        }


        return waves;
    }

    private void WinGame()
    {
        Debug.Log("Game won!");
        LeaderBoardManager.instance.UploadScore();
        SceneLoader.instance.LoadMenuScene();
    }

    public void OnEnemyDied()
    {
        enemiesAlive--;
        enemiesKilled++;

        if (enemiesKilled >= neededEnemieQuota)
            WinGame();
    }
}
